#!/usr/bin/env python
"""Unified environment setup utility for Opifex.

This script provides Python-based environment setup and management utilities,
complementing the main setup.sh script. It offers programmatic access to
environment configuration, dependency management, and GPU detection.

Usage:
    python scripts/setup_env.py --help           # Show all options
    python scripts/setup_env.py check            # Check environment status
    python scripts/setup_env.py verify           # Verify installation
    python scripts/setup_env.py clean            # Clean environment
    python scripts/setup_env.py create-env       # Create .env file only

Note: For full environment setup, use ./setup.sh instead.
"""

import argparse
import os
import subprocess
import sys
from pathlib import Path
from typing import Any


# Add script directory to path to import gpu_utils
script_dir = Path(__file__).parent
sys.path.insert(0, str(script_dir))


# Color codes for output
class Colors:
    """ANSI color codes for terminal output formatting."""

    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[1;33m"
    BLUE = "\033[0;34m"
    PURPLE = "\033[0;35m"
    CYAN = "\033[0;36m"
    NC = "\033[0m"  # No Color


def log_info(msg: str) -> None:
    """Log an informational message."""
    print(f"{Colors.BLUE}ðŸ’¡ {msg}{Colors.NC}")


def log_success(msg: str) -> None:
    """Log a success message."""
    print(f"{Colors.GREEN}âœ… {msg}{Colors.NC}")


def log_warning(msg: str) -> None:
    """Log a warning message."""
    print(f"{Colors.YELLOW}âš ï¸  {msg}{Colors.NC}")


def log_error(msg: str) -> None:
    """Log an error message."""
    print(f"{Colors.RED}âŒ {msg}{Colors.NC}")


def run_command(
    cmd: str,
    desc: str | None = None,
    exit_on_error: bool = True,
    print_output: bool = True,
) -> subprocess.CompletedProcess:
    """Run a shell command and optionally exit on error.

    Args:
        cmd: Command to run
        desc: Optional description to display
        exit_on_error: Whether to exit if command fails
        print_output: Whether to print command output

    Returns:
        CompletedProcess result object
    """
    if desc:
        log_info(desc)

    # Use bash explicitly for commands that need source builtin
    result = subprocess.run(
        cmd,
        shell=True,
        text=True,
        capture_output=True,
        executable="/bin/bash",
        check=False,
    )

    if print_output:
        if result.stdout:
            print(result.stdout.rstrip())
        if result.stderr and result.returncode != 0:
            print(result.stderr.rstrip(), file=sys.stderr)

    if exit_on_error and result.returncode != 0:
        log_error(f"Command failed: {cmd}")
        sys.exit(result.returncode)

    return result


def create_env_file(has_cuda: bool = False) -> None:
    """Create .env file with appropriate configuration.

    This aligns with the setup.sh script's .env generation.

    Args:
        has_cuda: Whether CUDA/GPU support is available
    """
    log_info("Creating environment configuration...")

    # Get the project root directory
    project_root = Path.cwd()

    if has_cuda:
        # Check if dot_env_template exists
        template_path = project_root / "dot_env_template"
        if template_path.exists():
            # Use the template file
            with open(template_path) as src, open(".env", "w") as dst:
                content = src.read()
                # Replace $(pwd) with actual path
                content = content.replace(
                    'PROJECT_DIR="$(pwd)"', f'PROJECT_DIR="{project_root}"'
                )
                dst.write(content)
            log_success("Created GPU-enabled .env from template")
        else:
            # Create GPU configuration matching setup.sh
            env_content = f"""# Opifex Environment Configuration - GPU Enabled
# Auto-generated by setup_env.py

# CUDA Library Configuration - Use local venv CUDA installation
# Point to locally installed CUDA libraries in venv
export LD_LIBRARY_PATH="{project_root}/.venv/lib/python3.12/site-packages/nvidia/cublas/lib:"\
"{project_root}/.venv/lib/python3.12/site-packages/nvidia/cusolver/lib:"\
"{project_root}/.venv/lib/python3.12/site-packages/nvidia/cusparse/lib:"\
"{project_root}/.venv/lib/python3.12/site-packages/nvidia/cudnn/lib:"\
"{project_root}/.venv/lib/python3.12/site-packages/nvidia/cufft/lib:"\
"{project_root}/.venv/lib/python3.12/site-packages/nvidia/curand/lib:"\
"{project_root}/.venv/lib/python3.12/site-packages/nvidia/nccl/lib:"\
"{project_root}/.venv/lib/python3.12/site-packages/nvidia/nvjitlink/lib:${{LD_LIBRARY_PATH}}"

# JAX Configuration for CUDA
export JAX_PLATFORMS="cuda,cpu"
export XLA_PYTHON_CLIENT_PREALLOCATE="false"
export XLA_PYTHON_CLIENT_MEM_FRACTION="0.8"
export XLA_FLAGS="--xla_gpu_strict_conv_algorithm_picker=false"

# JAX CUDA Plugin Configuration
export JAX_CUDA_PLUGIN_VERIFY="false"
# export JAX_SKIP_CUDA_CONSTRAINTS_CHECK="1"  # Disabled to catch CUDA version mismatches

# Reduce CUDA warnings
export TF_CPP_MIN_LOG_LEVEL="1"

# Performance settings
export JAX_ENABLE_X64="0"

# Development settings
export PYTHONPATH="${{PYTHONPATH:+${{PYTHONPATH}}:}}{project_root}"

# Testing configuration
export PYTEST_CUDA_ENABLED="true"

# Protobuf Configuration to fix compatibility issues
export PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION="python"
"""
            with open(".env", "w") as f:
                f.write(env_content)
            log_success("Created GPU-enabled .env configuration")
    else:
        # Create CPU-only configuration
        env_content = f"""# Opifex Environment Configuration - CPU Only
# Auto-generated by setup_env.py

# JAX Configuration for CPU
export JAX_PLATFORMS="cpu"
export JAX_ENABLE_X64="0"

# Development settings
export PYTHONPATH="${{PYTHONPATH:+${{PYTHONPATH}}:}}{project_root}"

# Testing configuration
export PYTEST_CUDA_ENABLED="false"

# Performance settings
export TF_CPP_MIN_LOG_LEVEL="1"

# Protobuf Configuration to fix compatibility issues
export PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION="python"
"""
        with open(".env", "w") as f:
            f.write(env_content)
        log_success("Created CPU-only .env configuration")


def detect_gpu() -> tuple[bool, str | None]:
    """Detect if NVIDIA GPU is available.

    Returns:
        Tuple of (has_gpu, gpu_name)
    """
    try:
        result = subprocess.run(
            ["nvidia-smi", "--query-gpu=name", "--format=csv,noheader"],
            capture_output=True,
            text=True,
            check=False,
        )
        if result.returncode == 0 and result.stdout.strip():
            gpu_name = result.stdout.strip().split("\n")[0]
            return True, gpu_name
    except FileNotFoundError:
        pass
    return False, None


def check_cuda_installation() -> bool:
    """Check if CUDA is properly installed.

    Returns:
        True if CUDA is available
    """
    # Check standard CUDA locations
    cuda_paths = [
        "/usr/local/cuda",
        os.environ.get("CUDA_HOME", ""),
        os.environ.get("CUDA_ROOT", ""),
    ]

    for path in cuda_paths:
        if path and Path(path).exists():
            return True

    # Check if nvcc is available
    try:
        result = subprocess.run(["nvcc", "--version"], capture_output=True, check=False)
        return result.returncode == 0
    except FileNotFoundError:
        pass

    return False


def check_environment() -> dict[str, Any]:
    """Check the current environment status.

    Returns:
        Dictionary with environment information
    """
    info = {
        "venv_exists": Path(".venv").exists(),
        "env_file_exists": Path(".env").exists(),
        "activate_script_exists": Path("activate.sh").exists(),
        "uv_lock_exists": Path("uv.lock").exists(),
        "gpu_available": False,
        "gpu_name": None,
        "cuda_available": False,
        "python_version": None,
        "jax_version": None,
        "jax_backend": None,
        "virtual_env_active": os.environ.get("VIRTUAL_ENV") is not None,
    }

    # Check GPU
    info["gpu_available"], info["gpu_name"] = detect_gpu()
    info["cuda_available"] = check_cuda_installation()

    # Get Python version
    try:
        result = subprocess.run(
            [sys.executable, "--version"], capture_output=True, text=True, check=False
        )
        if result.returncode == 0:
            info["python_version"] = result.stdout.strip()
    except Exception:
        pass

    # Check JAX if in virtual environment
    if info["virtual_env_active"]:
        try:
            import jax

            info["jax_version"] = jax.__version__
            info["jax_backend"] = jax.default_backend()
            info["jax_devices"] = len(jax.devices())
        except ImportError:
            pass

    return info


def print_environment_status() -> None:
    """Print the current environment status."""
    info = check_environment()

    print(f"{Colors.BLUE}ðŸ” Opifex Environment Status{Colors.NC}")
    print("=" * 40)

    # Virtual environment
    if info["venv_exists"]:
        log_success("Virtual environment exists (.venv)")
        if info["virtual_env_active"]:
            log_success("Virtual environment is active")
        else:
            log_warning("Virtual environment not active (run: source ./activate.sh)")
    else:
        log_warning("No virtual environment found (run: ./setup.sh)")

    # Configuration files
    if info["env_file_exists"]:
        log_success(".env configuration file exists")
    else:
        log_warning(".env file not found")

    if info["activate_script_exists"]:
        log_success("activate.sh script exists")
    else:
        log_warning("activate.sh not found")

    # GPU/CUDA status
    if info["gpu_available"]:
        log_success(f"GPU detected: {info['gpu_name']}")
        if info["cuda_available"]:
            log_success("CUDA installation found")
        else:
            log_warning("CUDA not found in standard locations")
    else:
        log_info("No GPU detected (CPU-only mode)")

    # Python/JAX status
    if info["python_version"]:
        log_info(f"Python: {info['python_version']}")

    if info["jax_version"]:
        log_success(f"JAX {info['jax_version']} installed")
        log_info(f"JAX backend: {info['jax_backend']}")
        log_info(f"JAX devices: {info['jax_devices']}")
    elif info["virtual_env_active"]:
        log_warning("JAX not installed in virtual environment")


def clean_environment(deep_clean: bool = False) -> None:
    """Clean the environment.

    Args:
        deep_clean: Whether to perform deep cleaning including caches
    """
    log_info("Cleaning environment...")

    # Basic cleaning
    if Path(".venv").exists():
        run_command(
            "rm -rf .venv", desc="Removing virtual environment", exit_on_error=False
        )

    if Path("uv.lock").exists():
        run_command("rm -f uv.lock", desc="Removing lock file", exit_on_error=False)

    if Path(".env").exists():
        run_command("rm -f .env", desc="Removing .env file", exit_on_error=False)

    # Remove old activation scripts
    old_scripts = [
        "activate_opifex.sh",
        "activate_env.sh",
        "activate_opifex_venv.sh",
        "setup_dev.sh",
    ]
    for script in old_scripts:
        if Path(script).exists():
            Path(script).unlink()
            log_info(f"Removed old script: {script}")

    # Python cache
    run_command(
        'find . -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true',
        desc="Cleaning Python cache",
        exit_on_error=False,
    )

    if deep_clean:
        log_info("Performing deep clean...")

        # JAX cache
        jax_cache = Path.home() / ".cache" / "jax"
        if jax_cache.exists():
            run_command(
                f"rm -rf {jax_cache}", desc="Removing JAX cache", exit_on_error=False
            )

        # pytest cache
        if Path(".pytest_cache").exists():
            run_command(
                "rm -rf .pytest_cache",
                desc="Removing pytest cache",
                exit_on_error=False,
            )

        # Coverage files
        run_command(
            "rm -f .coverage .coverage.*",
            desc="Removing coverage files",
            exit_on_error=False,
        )
        if Path("htmlcov").exists():
            run_command(
                "rm -rf htmlcov", desc="Removing coverage HTML", exit_on_error=False
            )

        # uv cache
        run_command("uv cache clean", desc="Cleaning uv cache", exit_on_error=False)

    log_success("Environment cleaned")


def verify_installation() -> bool:
    """Verify that the installation is working correctly.

    Returns:
        True if verification passes
    """
    log_info("Verifying installation...")

    # Check if virtual environment is active
    if not os.environ.get("VIRTUAL_ENV"):
        log_error("Virtual environment not active")
        log_info("Please run: source ./activate.sh")
        return False

    # Test imports
    try:
        import flax
        import jax
        import jax.numpy as jnp
        import optax

        log_success("Core dependencies imported successfully")
        log_info(f"  JAX: {jax.__version__}")
        log_info(f"  Flax: {flax.__version__}")
        log_info(f"  Optax: {optax.__version__}")

        # Test basic computation
        x = jnp.array([1.0, 2.0, 3.0])
        y = jnp.sum(x**2)
        log_success(f"Basic computation test: {float(y)}")

        # Check devices
        devices = jax.devices()
        gpu_devices = [d for d in devices if d.platform == "gpu"]

        log_info(f"Available devices: {len(devices)}")
        if gpu_devices:
            log_success(f"GPU devices: {len(gpu_devices)}")
            # Simple GPU test
            try:
                with jax.default_device(gpu_devices[0]):
                    z = jnp.array([1.0, 2.0, 3.0])
                    w = jnp.dot(z, z)
                log_success(f"GPU computation test: {float(w)}")
            except Exception as e:
                log_warning(f"GPU test warning: {e}")
        else:
            log_info("No GPU devices (CPU-only mode)")

        log_success("Installation verification complete!")
        return True

    except ImportError as e:
        log_error(f"Import error: {e}")
        log_info("Dependencies may not be installed. Run: ./setup.sh")
        return False
    except Exception as e:
        log_error(f"Verification error: {e}")
        return False


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Opifex environment setup and management utility",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""Examples:
  python scripts/setup_env.py check        # Check environment status
  python scripts/setup_env.py verify       # Verify installation
  python scripts/setup_env.py clean        # Clean environment
  python scripts/setup_env.py create-env   # Create .env file

Note: For full environment setup, use ./setup.sh instead.
""",
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Check command
    subparsers.add_parser("check", help="Check environment status")

    # Verify command
    subparsers.add_parser("verify", help="Verify installation")

    # Clean command
    clean_parser = subparsers.add_parser("clean", help="Clean environment")
    clean_parser.add_argument(
        "--deep", action="store_true", help="Perform deep cleaning including caches"
    )

    # Create-env command
    env_parser = subparsers.add_parser(
        "create-env", help="Create .env configuration file"
    )
    env_parser.add_argument(
        "--cpu-only", action="store_true", help="Create CPU-only configuration"
    )

    return parser.parse_args()


def main():
    """Main entry point."""
    args = parse_args()

    if not args.command:
        # Default to check if no command given
        print_environment_status()
        print("\nUse --help for more options")
        return 0

    if args.command == "check":
        print_environment_status()

    elif args.command == "verify":
        if verify_installation():
            return 0
        return 1

    elif args.command == "clean":
        clean_environment(deep_clean=args.deep)

    elif args.command == "create-env":
        has_gpu, gpu_name = detect_gpu()
        if args.cpu_only:
            has_gpu = False
            log_info("Creating CPU-only configuration (--cpu-only specified)")
        elif has_gpu:
            log_success(f"GPU detected: {gpu_name}")
        else:
            log_info("No GPU detected, creating CPU-only configuration")
        create_env_file(has_cuda=has_gpu)

    return 0


if __name__ == "__main__":
    sys.exit(main())
